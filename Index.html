<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Programming</title>
</head>
<body>
    <h1>What is C</h1>
    <p>Its an imperative procedural language. All the code has to be inside a function. C files are the source code of your program.
        You have to compile the C files with a compiler like gcc to make an executable file.
    </p>
    <h2>Comments</h2>
    <p>In C we use /* and end with */</p>
    <h2>Variables</h2>
    <p>Here we have data types and integer types which are the following and each has a storage size it takes</p>
    <ul>
        <li>char.....1byte...(-128 to 127)</li>
        <li>unsigned char....1byte....(0 to 255)</li>
        <li>short.....2bytes....(-32768 to 32767)</li>
        <li>unsigned short .....2bytes......(0 to 65535)</li>
        <li>int....4bytes....(-2,147,483,648 to 2,147,483,647)</li>
        <li>unsigned int...4bytes......(0 to 4,294,967,295)</li>
        <li>long....8bytes....(âˆ’9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)</li>
        <li>unsigned long....8bytes.....(0 to 18,446,744,073,709,551,615)</li>
    </ul>
    <p>Variables have a Declaration too like for example ....type var_name;  or ...int i;.....or char c;</p>
    <h2>Arrays</h2>
    <p>An array is a succession of items of the same type in memory...example I can say ......
     int my_array[35]....or ...char my_array_arrays[16][32]</p>
     <h2>Structures</h2>
     <p>This is a complex data type declaration that defines a physically grouped list of variables to be placed under one name in 
        a block memory......creation and declarion is as follows...
        <br>
        <br>
        struct structure_name{
            type name;
            [...] 
        };
        struct structure_name var_name;
        <br>
        <br>
        struct new_struct{
            int a;
            char b[32];
        }
        struct new_struct s;
     </p>
     <br>
     <br>
     <h1>Functions, Programs</h1>
     <p>A program is a collection of functions. A function is a sequence of program instructions that perform a specific task 
        The syntax is as follows..
        <br>
        return_type function_name(type param, type2 param2 [...])
        [block]
        <br>
        example
        <br>
        int func(int a, char c)
        [block]
     </p>
     <br>
     <h2>The Entry Point</h2>
     <p>Note that programs begin with an entry point.....In C the entry point is main function. From the main function you can call 
        all other functions. When the main returns the program stops. ...
        <em>int main(void)......int main(int ac, char **av)</em>
     </p>
     <h2>Blocks</h2>
     <p>They are sections of codes that are grouped together. They are delimited  by curly braces.....syntax 
        <br>
        {
            [declaration(s)]

            [statements(s)]
        }
        <br>
        example
        <br>
        int func(int a, int b)
        {
            /* declarations */
            int mul; 
            int sum;
            int result;

            /* statements */
            mul = a * b;
            sum = a + b;
            result = mul + sum;
            return(result);
        }
     </p>
     <br>
     <h1>Instructions and Expressions</h1>
     <p>Expression followed by a semicolon indicates the end of one logical entity...They always have a value
        Types of expressions are......Basic expressions(arithmetic opertaions)....Affectations(assigning a value to a variable)
        ......Comparisons(checking the equality of values).....Logical Operations(checking whether tow things are the same).....
        Binary Opertaions.
     </p>
     <br>
     <h2>Characters</h2>
    <p>They are inside single quotes. The value of a character is its ASCII code(man ascii)</p>
    <h2>Strings</h2>
    <p>They are inside double quotes</p>
    <h2>Affectations</h2>
    <p>Their syntax as follows....... var_array[expressions] = expression;
                              ....... var_struct.field_name = expression;
    </p>
    <h2>Variable assignment  | example</h2>
    <p>
        int add(int a, int b, int c)
        {
            int result;

            result a +  b + c;
            [...]
        }
        int main()
        {
            int a;
            int b;
            
            b = 98;
            a = 1 + 2 + 3 * 4 - 1;
            b = 23 +add(32, a, a + b);
            [...]
        }
    </p>
    <br>
    <br>
    <h1>Control Structures</h1>
    <p>Here we have .....if.... and if else statements.... </p>
    <h3>while loops</h3>
    <p>syntax.....
        while(expression)
          [block]
          <br>
       While loop lets you repeat a block until a specified expression becomes false.
       <br>
       <br>
       int array_var[98];
       int i;
       
       i = 0;
       while (i < 98)
       {
          array_var[i] = 1337;
          i++;
       }
    </p>
    <h3>for loops</h3>
    <p>This one lets you repeat a block a specified number of times. Its executed until the optional condition becomes false.
         The syntax is as follows.....for(initialize; condition; update)
                                          [block]
        example
        <br>
        int array_var(98);
        int i;
        
        for(i = 0; i < 98; i++)
        {
            array_var[i] = 1337;
        }
    </p>

    <h1>Keywords and Identifiers</h1>
    <h2>Keywords</h2>
    <p>Some of the keywords in C programmng include the following......auto, break, if, while, int, else, struct, long, float, 
        static, char, register, return, signed, sizeof, goto, void, unsigned, enum, typedef, switch and many more. The new ones are 
        volatile, const, void and signed.
    </p>
    <h2>Identifiers</h2>
    <p>Its a fancy term used to mean name in C. The only restriction is that an identifier must start with an alphabetic character</p>
    <br>
    <br>
    <h1>Intergral Types.</h1>
    <p>We start by looking at various types of integers then their conversion rules.</p>
    <h2>Plain Integers</h2>
    <p>The most obvious one is <em>signed int</em> and the less obvious one is <em>unsigned int</em>.</p>
    <h2>Character Variables</h2>
    <p>This is simply the char. A char is just an integer.....Example of char is as below..........
        <br>
        <br>

        include <limits.h>
        include <stdio.h>  
        include <stdlib.h> 
         
        main(){
            char c;

            c = CHAR_MIN;
            while(c != CHAR_MIN){
                print("%d\n", c);
                c = c+1;
            }
              exit(EXIT_SUCCESS); 
        }    
    </p>
    <p>Its useful to be able to read characters in a program.The library function <em>getchar</em> is used for the job ....It 
    reads characters in a program and returns an int value which is stored in the char.</p>
    <br>
    <br>
         <h1>More Complicated Types</h1>
         <p>For serious systems programming they are just aren't adequete in the precision of control over storage that 
            they provide and behaviour that they follow. To correct this problem C provides extra Intergral types. They are 
            split into two categories ..... <em>signed and unsigned</em>. Signed are capable of being negative while unsigned
            cannot be negative at any time. unsigned also have a special character of not overflowing in arithmetic.
            <br>
            <br>
            #include <stdio.h>
                #include <stdlib.h>
                main(){
                      unsigned int x;
                      x = 0;
                      while(x >= 0){
                              printf("%u\n", x);
                              x = x+1;
                      }
                
                      exit(EXIT_SUCCESS);
                }
                <br>
                <br>
            For both signed and unsigned we have three subtypes, <em>short, ordinary and long.</em> Taking those into account, here is a 
            list of possible Intergral types in C....
            <ul>
                <li><em>unsigned short int</em></li>
                <li><em>unsigned int</em></li>
                <li><em>unsigned long int</em></li>
                <li><em>signed short int</em></li>
                <li><em>signed int</em></li>
                <li><em>signed long int</em></li>
            </ul>  
            <br>
            The last three signed are unnecessary since int types are signed types anyway. The only character types are signed
            and unsigned.  
         </p>
    <br>
    <br>
    <h1>Printing Intergral Types</h1>
    <p>You can use printf to print these various types. Character variables work exactly the same way as Intergral variables. 
        ......%c for char.....%d for decimal signed int, short and char..............%u for decimal unsigned int, short and char......
        ..%x for hexadecimal int, short and char .........%o for octo int, short and char.......%ld for decimal signed long......
        ....%lu %lx & %lo for as aboves but for longs
    </p>
    <br>
    <br>
    <h1>If Statements in C</h1>
    <p>Without a conditional staement such as if statements ....programs would run almost the same way every time. Lets check the difference 
        between TRUE and FALSE. A TRUE statement equal to a nonzero number while a FALSE statements equla to zero. The operator returns 1 if
        the condition is true and returns 0 is the condition is false.
    </p>
    <h3>Basic if statements</h3>
    <p>
        if(the statement is true)
         Execute this line of code
    </p>
    <br>
    <br>
      <h1>Variable Declaration in C</h1>
      <p>Provides assuarance to a compiler that there exists a variable of a certain type and name. We use the keyword extern to
        declare a variable at any place. 
      </p>
      <h1>Lvalues and Rvalues in C</h1>
      <p>lvalue refer to memory location while rvalue refer to data value that is stored at the same address memory.</p>
      <br>
      <br>
      <h1>Storage Classes</h1>
      <p>The different storage classes in C are ...auto, register, static and extern. The auto storage class is the default storage class 
        for all the variables. Register class is used to define all the local variables which should be stored in the register instead 
        of the RAM.....eg <em>register int age;</em>. The static storage class instructs the compiler to keep the local variables in 
        existence instead of destroying them. 
      </p>
      <h1>Misc Operators / Sizeof & Ternary</h1>
      <p>Here we have <em>sizeof(), & , *, ?:</em><br>& returns the address of the variable. .....* is a poiner to the variable.
     ...example *a. ?: is a conditional expression..example....if condition is true then value of X otherwise Y.</p>
     <br>
     <br>
     <h1>C Functions</h1>
     <p>A function is a group of statements that together perform a task. Every C program has at least one function which is main(). 
        Function declaration tells the compiler about the function name, return type and parameters. The C standard library proviides
        numerious built in functions that your program can call. For example, strcat() to concatenate tow strings......memcpy() to copy
        from one memory location to another.
        <br>
        <br>
        General form of a function in C is as follows.....
        <br>
        <br>
        return_type function_name( parameter list ){
            body of the function
        }
        <br>
        <br>
        The return_type is basically the data type a function returns. If a function is performing an operatation without returning a 
        value the return_type is the keyword void. A parameter is like a placeholder. When a function is invoked you pass a value to the 
        parameter.   
     </p>
     <br>
     <br>
     <h1>Calling a Function</h1>
     <p>When a program calls a function, the program control is transfered to the called function.To call a function you need to pass the 
        required parameters along with the function name and if the unction returns a value, then store the returned value.
     </p>

     <h1>Header Files</h1>
     <p>A header is a file with the extension <em>.h</em>. It contains the c functiomn declarations and macro definations to be shared 
    between several source files.There are tow types of header files, files that a programmer writes and the files that coe with your 
     compiler. The request to user a header file is by #include</p>
     <h2>Include Operation</h2>
     <p>#include directs the C preprocessor to scan specified file as the input before continuing with the rest of the current source file
        . 
     </p>
     <br>
     <br>
     <h1>Pointers and Arrays</h1>
     <p>A pointer is a variable which contains a memory address.</p>
     <h2>Types and Memory</h2>
     <p>Every time a variable is declared the computer reserves a memory for that variable. The memory reserved will then store the value
        of that variable. The size of a type will determine how many different possible values of a variable of this type can hold. When we declare a 
        variable the computer will reserve the right amount of space for the variable in the memory. 
     </p>
     <p>The size of a type will determine how many different possible values of a variable of this type can hold. For instant a char variable 
        could only hold 256 different values from -128 to 127. And because the size of int is 4bytes so 32, an int value can hold 2^32 different
        possible values. The space reserved for the variable is its address. And when we assign a value to this variable the computer will store
        the value this value at its address. Note that a byte can only store numbers. So if its a string lets say 'H',  its ascii code which is 
        72 is stored there. In order to know what is the address of a variable, you can use the "address-of unary operator" &. You can use %p to
        print addresses(the values of pointers) with printf. 
     </p>
     <br>
     <br>
     <h1>Storing Memory Addresses</h1>
     <p>Now that we know how to get an address, we can store it in a pointer. A pointer is simply the address of a piece of data
        . Like any other variable it needs to be declared. The general form is var_type *var; The star tell the variable var is
        a pointer, that points to var_type. The value of var will be a memory address holding a value of type var_type 
        int *ptr; In this example the ptr is the name of the variable of type "pointer to an integer" 
     </p>
     <br>
     <br>
     <h1>Dereferencing</h1>
     <p>The real power of integers is that they can manipulate values stored at the memory address they point to. This is called dereferencing
        . To do this you can use the dereference 
     </p>
     <br>
     <h1>Arrays</h1>
     <p>A variable is a name given to a storage area that our programs can manipulate.</p>
     <h1>Lvalues and Rvalues</h1>
     <p>There are two kinds of expressions in C. lvalue are expressions that refer to a memory location. Rvalue refers to a data 
        value that is stored at some address in a memory. Variables are lvalues and so they may appear on he left-hand side of 
        an assignment.
     </p>
     <br>
     <br>
     <h2>C Constants and Literals</h2>
     <p>Constant refer to a fixed value that a program may not alter. Constants are also called Literals. They can be any type 
        of data type that is integer, character , float and string literals.  
     </p>
     <h2>Defining Constants</h2>
     <p>There are two simple ways in C to define constants. 
        <ul>
            <li>Using #define preprocessor</li>
            <li>Using const keyword</li>
        </ul>
     </p>
     <h1>The C Storage Classes</h1>
     <p>A storage class defines the scope(visibility) and life-time of variables or functions within C programs. The four different
        storage classes in C Program
        <ul>
            <li>auto</li>
            <li>register</li>
            <li>static</li>
            <li>extern</li>
        </ul>
     </p>
     <h3>The Auto Storage Class</h3>
     <p>Is the default storage class for all local variables. Can only be used within two functions. </p>
     <h3>The Register Storage Class</h3>
     <p>The register class is used to define local variables that should be stored in a register other than RAM. This means that 
        the variable has a maximum size equal to the register size. The register should only be used for variable which require quick
        access.
     </p>
     <h2>The Static Storage</h2>
     <p>The static class storage instructs the compile to keep a local variable in existence during the life-time of the program 
        instead of creating and destroying it each time. Therefore making local variable static allows them to maintain their value 
        between function calls. In C Programming when static is used on global variable, it causes only one copy of that member to be
        shared by all the objects of that class. 
     </p>
     <h1>Decision Making</h1>
     <p>Decision making structures require that the programmer specifies one or more conditions to be evaluated along with a statement
        to be executed if the condition is found to be true. The general flow of the decision making structure is as follows. If condition
        is true...conditional code the execution....if the condition is false its executed and the onditional code is not used. We have if
         statements....if else ....nested if......switch statement and nested switch 
     </p>
     <h3>The ?: Operator</h3>
     <p>Checking on the operators before this we learn the following..</p>
     <ul>
        <li>Arithmetic Operators</li>
        <li>Relational Operators</li>
        <li>Logical Operators</li>
        <li>Bitwise Operators</li>
        <li>Assignment Operators</li>
        <li>Misc Operators</li>
     </ul>
     <h4>Arithmetic Operators</h4>
     <p>They are the following ....+, = , -, *, /, % , ++, --</p>
     <h4>Relational Operators</h4>
     <p>They are ==, !=, <, >, <=, >= </p>
     <h4>Logical Operators</h4>
     <p>They include ..&&, ||, !</p>
     <h4>Bitwise Operator</h4>
     <p>Bitwise operator works on bit-by-bit operation. The truth table for &, | and ^ is as follows...
      The bitwise operators supported in C are &, |, ^,      
     </p>
     <h3>Back to ?: operator</h3>
     <p>The format is as follows...if Exp1 is true, Exp2 is evaluated and if Exp1 is false Exp3 is evaluated. Exp1 ? Exp2 : Exp3</p>
     <h2>C Loops</h2>
     <p>A Loop allows us to execute a statement or a group of statements muiltiple times. Types of loops in C Programming language are
        while loop, for loop, do....while loop and nested loops. 
     </p>
     <br>
     <br>
      <h1>Pointer to Pointer</h1>
      <p>A pointer is a form of multiple indirection or a chain of pointers. </p> 
      <br>
      <br>
      <h1>Recursion</h1>
      <h3>Iterative Programming</h3>
      <p>This is the repetition of a block of statements in a computer program using a loop</p>
      <br>
      <p>Recursion is a method where the solution to a problem depends on the solution to smaller instances of the same problem
        A recursive finction is a function that calls itself 
      </p>
      <br>
      <br>
      <h1>Building and Using Static and Shared C Libraries</h1>
      <p>One of the problems with developed programs is that they tend to grow larger and larger with time hence bringing about
        larger compilation files. 
      </p>
      <h2>What is a C library and What can it do?</h2>
      <p>A library is a file containing several object files that can be used as a single entity in a linking phase of a program
        . We have Static Libraries and dynamic Libraries. Static libraries are a collection of object files that are linked in the program
        during the linking phase of compilation and are not relevant during runtime. Dynamic Libraries also called shared libraries are 
        linked in the program in two stages. First during compile time, the linker verifies that all symbols required by the program are 
        linked into the program or one of its shared libraries. These sysmbols are again, functions, variables and the like. However the
        object files from the dynamic library are not inserted in the executable file, instead when a proram is started, a program system
        called the dynamic loader checks out which shared libraries are linked with the program, loads to the memory and attaches them 
        the copy of the program in the memory.  
      </p>
      <h2>Creating a Static C library using "ar" and "ranlib"</h2>
      <p>The basic tool used to create static libraries is a program called 'ar', for 'archiver'. In order to create a static library, we
        can use a command like this '<em>ar rc libutil.a util_file.o util_net.o util_math.o ....This command creates a static library 
            called 'libutil.o' and puts copies of the object files 'util_file.o', util_math.o and util_net.o in them. 
        </em>'. After the archive is created or modifies there ia a need to index. The comand used to create or update the index is 
        called ranlib and is used as follows. <em>'ranlib libutil.a'</em>. 
      </p>
      <h2>Using a C Library in A Program</h2>
      <p>After we created our archive we want to use it in our program, this is done by adding the library's name to the list of 
        object file names given to the linker using a speacial flag normally ' -l '. Example..... <em>'cc main.o -l. -lutil -o prog'</em>
        This will create a program using object file 'main.o' and any other sysmbols it rquires from the 'util' static library.  
      </p>
       <br>
       <br>
      <h2>Creating A Shared 'C' Library using 'ld'</h2>
      <p>Compile list files then insert </p>
      <br>
      <br>
      <h2>Arguments to main</h2>
      <p>For those writing programs which will run in a hosted environment, arguments provide a useful opportunity to give parameters
         to programs. Typically this facility is used to direct the way the program goes about its task. Its particularly common to
         provide file names to a program through its arguments. The declaration of main looks like this.......  int main(int argc, char 
         *argv). This indicates that the main is a function that returns a integer. There are atleast two arguments in main which are 
      </p>
      <h1>Object-like Macros</h1>
      <p>An object-like macro is a simple identifier which will be replaced by a code fragment. It looks like a data object in the code. They are most 
        commonly used to give symbolic names to numeric constants. You create macros with the #define directive. #define is followed by the name of the 
        macro and then the token sequence it should be an abbreviation for, which is variously refered to as macro body, expansion or replacement list. 
        for example <em>
            #define BUFFER_SIZE 1024
        defines a macro named BUFFER_SIZE as an abbreviation for the token 1024. If somewhere after this #define directive there comes a C statement
        of the form .....
        <br>
        foo = (char *) malloc (BUFFER_SIZE); 
        <br>
        then the C processor will recognise and expand the macro BUFFER_SIZE. The C compiler will see the same token as it would be if it was written as
        <br>
        foo = (char *) malloc (1024);
        <br>
        By convention macro names are written in uppercase.
        </em>
        <br>
        Macro's body ends at the end of the #define line. You may continue the defination into multiple lines, if necessary, using backslash-newline.
        When macro is expanded however it will come out on one line....for example 
        <br>
        <em>
            #define NUMBERS 1, \
                            2, \
                            3
            int x[] = {NUMBERS};
              ==> int x[] = {1, 2, 3}; 
        </em>
        <br>
        The common visible consequences of this is surprising line numbers in error messages. Macro definations take effect at the place you write them
        . Therefore the following input to the C Processor 
        <br>
        <em>
            foo = x;
            #define x 4
            bar = x;
        </em>
        <br>
        produces 
        <br>
        <em>
            foo = x;
            bar = 4;
        </em>
        <br>
        When the preprocessor expands the macro name, the macro name expansion replaces the macro invocation, then the expansion is examined for more 
        macros to expand....for example
        <em>
            #define TABLESIZE BUFSIZE
            #define BUFSIZE 1024
            TABLESIZE
               ==> BUFSIZE
               ==> 1024
        </em>
        TABLESIZE is expanded first to produce BUFSIZE, then that macro is expanded to produce final result, 1024.
      </p>
      <br>
      <h1>Macro Arguments</h1>
      <p>Function-like macros can take arguments, just like true functions. To define a macro that uses arguments, you insert parameters between the 
        pair of paranthesis in the macro defination that make the macro function-like. The parameters must be valid C identifiers, separated by commas and optionally
        white space. To invoke a macro that takes arguments, you write the name of the macro followed by a list of actual arguments in paranthesis, separated by commas
        . It can cross many lines in the source file as you wish. The number of arguments you give must match the number of parameters in the macro definition. When
        the macro is expanded, each use of a parameter in its body is replaced by the tokens of the corresponding arguments.
        Here is an example of a macro that computes the minimum of two numerical values, as it is defined in many C programs and some uses.
        <br>
        <br>
        <em>
            #define min(X, Y) ((X) <  (Y) ? (X) : (Y))
            x = min(a, b);          ==> x = ((a) < (b) ? (a) : (b));
            y = min(1, 2);          ==> y = ((1) < (2) ? (1) : (2));
            z = min(a + 28, *p);    ==> z = ((a + 28) < (*p) ? (a + 28) : (*p));
        </em> 
        <br>
        In this small exmple you can already see several of the dangers of macro arguments. 
        <br>
        Leading and trailing whitespace in each argument is dropped and all the whitespace between tokens of an argument is reduced to a single space. Paranthesis
        within each argument must balance, a comma within within such paranthesis does not end the argument. However, there is no requirement for square brackets
        or braces to balance and they do not prevent a comma from separating arguments. Thus,
        <br>
        <em>
            macro (array[x = y, x + 1])     .....passes two arguments to macro: array[x = y and x + 1]. If you want to supply array[x = y, x + 1] as an argument, 
            you can write it as array[(x = y, x + 1)] which is equivalent  to C code. All arguments to a mcro are completely macro-expanded before they are substituted
            into the macro body. After substitution, the complete text is scanned again for macros to expand,including the arguments. This rule may seem strange but
            it is carefully designed.
            <br>
            For example ... min(min(a, b), c) is first expanded to .... min(((a) < (b) ? (a) : (b)), (c))......then to .....
            (((a) < (b) ? (a) : (b)) < (c) ? (((a) < (b) ? (a) : (b))) : (c))
        </em>
        <br>
        Line breaks shown for clarity would not actually be genarated.
      </p>
      <h1>Pre-Processor Directives in C</h1>
      <p>The C Pre Processor is not part of the compiler but its a step executed before the source code is compiled. The pre-processor can replace tokensin the
        , insert contents of other files into the source file or suppress compilation of part of the file by removng sections of text. The two pre-processor 
        directves are #define and #ifdef 
      </p>
      <br>
      <h1>The C Pre-Processor</h1>
      <p>The C Pre-Processor modifies the source code file before handing it over to the compiler. There are essentially three uses of pre-processor directives,
         constants and macros. Directives are commands that tell the pre-processor to skip part of a file, include another file or define a constant or macro. 
         Directives always begin with a sharp sign(#) .
      </p>
      <br>
      <h2>Header Files</h2>
      <p>The #include directive tells the pre-processor to grab the text of a file and place it directly into the current file. Typically, such statements are
        placed at the top of a program hence the name header files. 
      </p>
      <h3>Conditional Compliation</h3>
      <p>There are a whole set of options that can be used to determine whether the processor will remove lines of code before handing the file to the compiler.
        They include #if #else #ifdef and #ifndef
      </p>
      <h3>Include Guards</h3>
      <p>Another common problem is that a header file is required in multiple other header files that are later included into a source code file, with the
        result often being that variables, structs, classes or functions appear to be defined multiple times. 
      </p>
      <br>
      <h3>Macros</h3>
      <p>The other major use of preprocessor is to define macros. The advantage of a macro is that it can be type-neutral and its inlined directly into the 
        code, so there isn't any function call overhead. A macro definition is always of the following form. 
        <br>
        <em>
            #define MACRO_NAME(arg1, arg2,...) [code to expand].............for instant a simple increment macro might look like this; ......
            <br>
            #define INCREMENT(x) x++
        </em>
      </p>
      <br>
      <br>
      <h1>Structures in C Programming</h1>
      <p>A structure is a user  defined data type available in C that allows to combine data items of different kinds. 
        <br>
        Structure declaration
        <br>
        <em>
            struct User
            {
                char *name;
                char *email;
                int age;
            };

            int main(void)
            {
                struct User user;
                user.name = "Foo Bar";
                user.email = "foobar.io";
                user.age = 22;
                return (0);
            }
        </em>
        To access elements of a pointer to a structure, you have to dereference the pointer and then access to the data using the '.' symbol. 
      </p>
      <br>
      <h1>typedef</h1>
      <p>In C programming we have the keyword typedef which you can use to give a type a new name. After you type defination, the identifier byte can be used 
        as an abbreviation for type unsigned char like in the example.... 
        <br>
        typedef unsigned char byte;

        int main(void)
        {
            byte c;

            c = 200;
            return (0);
        }
        <br>
        You can also use typedef with structures to define a new data type 
        <br>
        struct Computer
        {
            char *name;
            char *brand;
        };

        typedef struct Computer Computer
        <br>
        <br>
        typedef struct Computer
        {
            char *name;
            char *brand;
        } Computer;
      </p>
</body>
</html>